paginate using the "Next" and "Previous" buttons, the href in @Url.Action("Userpage", ...) changes the route to "Userpage", which is why your URL changes from "home/menu" to "Userpage".

Since you're using a partial view, you likely want to update only the partial content without changing the URL. You can achieve this using AJAX instead of full-page reloads.

Solution: Use AJAX to Load the Partial View Dynamically
Instead of using @Url.Action(...) directly in <a> tags, use JavaScript to send an AJAX request when pagination or pageSize changes.

1. Modify Your View to Use AJAX
Replace Pagination Links and Page Size Dropdown
Modify your HTML to trigger an AJAX request instead of a full-page reload.

html
Copy code
<div class="d-flex justify-content-end align-items-center my-3 gap-2">
    <form id="paginationForm" method="get" class="d-flex align-items-center me-3">
        <span class="me-2">Items per page:</span>
        <select name="pageSize" class="form-select form-select-sm w-auto me-3" id="pageSizeDropdown">
            <option value="5" @(Context.Request.Query["pageSize"] == "5" ? "selected" : "")>5</option>
            <option value="10" @(Context.Request.Query["pageSize"] == "10" ? "selected" : "")>10</option>
            <option value="15" @(Context.Request.Query["pageSize"] == "15" ? "selected" : "")>15</option>
            <option value="20" @(Context.Request.Query["pageSize"] == "20" ? "selected" : "")>20</option>
        </select>

        <!-- Pagination Summary -->
        <span id="pagination-summary" class="text-muted">
            Showing @(Model.PageSize * (Model.PageNumber - 1) + 1)
            - @((Model.PageSize * Model.PageNumber) > Model.TotalItemCount ? Model.TotalItemCount :
                                (Model.PageSize * Model.PageNumber))
            of @Model.TotalItemCount results
        </span>
    </form>

    <!-- Previous Button -->
    <button id="prevPage" class="btn btn-outline-dark @(Model.HasPreviousPage ? "" : "disabled")">
        <i class="fa-solid fa-chevron-left"></i>
    </button>

    <!-- Next Button -->
    <button id="nextPage" class="btn btn-outline-dark @(Model.HasNextPage ? "" : "disabled")">
        <i class="fa-solid fa-chevron-right"></i>
    </button>
</div>

<!-- Partial View Container -->
<div id="partialViewContainer">
    @await Html.PartialAsync("_YourPartialView")
</div>
2. Use AJAX to Load Partial View Dynamically
Add this JavaScript at the end of your view (or in a separate file):

javascript
Copy code
$(document).ready(function () {
    function loadPartialView(page, pageSize) {
        $.ajax({
            url: "/home/menu",  // Keep the route unchanged
            type: "GET",
            data: {
                page: page,
                pageSize: pageSize,
                search: new URLSearchParams(window.location.search).get("search"),
                filterBy: new URLSearchParams(window.location.search).get("filterBy"),
                sortBy: new URLSearchParams(window.location.search).get("sortBy")
            },
            success: function (data) {
                $("#partialViewContainer").html($(data).find("#partialViewContainer").html());
            },
            error: function () {
                alert("Failed to load data. Please try again.");
            }
        });
    }

    // Handle Page Size Change
    $("#pageSizeDropdown").change(function () {
        let pageSize = $(this).val();
        loadPartialView(1, pageSize); // Reset to page 1 when changing page size
    });

    // Handle Pagination
    $("#prevPage").click(function () {
        let currentPage = parseInt(new URLSearchParams(window.location.search).get("page") || 1);
        if (currentPage > 1) {
            loadPartialView(currentPage - 1, $("#pageSizeDropdown").val());
        }
    });

    $("#nextPage").click(function () {
        let currentPage = parseInt(new URLSearchParams(window.location.search).get("page") || 1);
        loadPartialView(currentPage + 1, $("#pageSizeDropdown").val());
    });
});
3. Modify Your Controller (HomeController.cs)
Make sure your controller returns the partial view when it's an AJAX request:

csharp
Copy code
public IActionResult Menu(int page = 1, int pageSize = 5, string search = "", string filterBy = "", string sortBy = "")
{
    var model = _yourService.GetPagedData(page, pageSize, search, filterBy, sortBy);

    if (Request.Headers["X-Requested-With"] == "XMLHttpRequest") // Check if it's an AJAX request
    {
        return PartialView("_YourPartialView", model);
    }

    return View(model);
}
How This Works
Pagination and pageSize changes trigger AJAX requests instead of a full-page reload.
The loadPartialView() function loads only the partial view's content, keeping the URL unchanged (/home/menu).
The controller detects AJAX requests and returns only the partial view, preventing layout re-rendering.
Expected Outcome
The route stays /home/menu instead of changing.
Pagination and page size changes work dynamically without reloading the page.
The user experience improves as only relevant content updates.
Would you like to enhance this further with additional features like loading indicators or smooth transitions?
